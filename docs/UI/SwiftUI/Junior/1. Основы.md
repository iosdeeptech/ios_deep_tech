
---

> **Изучение данного блока предполагает предварительное знание синтаксиса языка Swift.**
*Для успешного освоения этого материала, необходимо иметь базовое понимание синтаксиса языка Swift. Это включает в себя знание основных структур данных, операторов, циклов, функций, абстракций и других ключевых элементов языка. Без этих фундаментальных знаний будет сложно понять более сложные концепции и примеры, которые будут рассматриваться в данном блоке.*
> 

---
**SwiftUI** позволяет строить интерфейс с использованием простого и интуитивно понятного синтаксиса, основанного на декларативных компонентах. Вместо традиционного императивного подхода, где вы явно указываете, как и когда обновлять элементы интерфейса, SwiftUI позволяет описать, как интерфейс должен выглядеть в зависимости от текущего состояния данных.
### Принцип работы SwiftUI
- **Декларативный подход**

Разработчик описывает, что должно быть на экране, а фреймворк сам решает, как это отобразить.
- **Реактивность**

SwiftUI автоматически обновляет интерфейс при изменении данных — Data Driven UI. Это достигается благодаря использованию свойств, помеченных специальными атрибутами.
- **Композиция представлений**

Вместо наследования, SwiftUI использует композицию. Представления можно комбинировать друг с другом, чтобы создавать сложные интерфейсы.
# Протокол View
Представляет абстракцию для всех элементов интерфейса. В SwiftUI любой компонент UI, который вы создаете, должен соответствовать этому протоколу:
```swift
public protocol View {
    associatedtype Body: View
    var body: Self.Body { get }
}
```
`associatedtype Body: View` — это ассоциированный тип, который указывает, какой тип является “телом” представления. Важно, что тело также должно быть типом, соответствующим протоколу View.

`var body: Self.Body { get }`  — это свойство, которое возвращает представление, описывающее то, как отображается UI-компонент. body должен возвращать что-то, что также соответствует протоколу View.
## Почему используются структуры, как наследники View?
- **Неизменяемость**

Структуры в Swift по умолчанию являются неизменяемыми. Это означает, что состояние представления не может быть изменено напрямую, что упрощает управление состоянием и делает код более предсказуемым.
- **Производительность**

Структуры обычно легче и быстрее по сравнению с классами, так как не требуют управления памятью через ARC (*Automatic Reference Counting*).
## Как работает под “капотом”?
- **Система отображения и обновления**

SwiftUI использует рекурсивную систему для отображения представлений и отслеживания изменений в их состоянии. Когда состояние изменяется, SwiftUI автоматически пересчитывает и обновляет только те части интерфейса, которые были изменены.
- **Diffing**

Для минимизации изменений на экране, SwiftUI использует алгоритмы диффинга, которые определяют, какие части дерева представлений изменились, и применяют только необходимые обновления.
- **Композиция и модификаторы**

Представления в SwiftUI являются композируемыми, что позволяет создавать сложные интерфейсы из простых строительных блоков. Модификаторы позволяют изменять представления, не изменяя их исходный код.
## Основные компоненты и их использование
- **Text** — Представление для отображения текста
```swift
Text("Hello, World!")
```
- **Image** — Представление для отображения изображения
```swift
Image(systemName: "star")
```
- **Button —** Представление для создания кнопки
```swift
Button(action: {
    print("Button tapped")
}) {
    Text("Tap me")
}
```
- **List —** Представление для создания списка элементов
```swift
List {
    Text("Item 1")
    Text("Item 2")
    Text("Item 3")
}
```
- **Stack (VStack, HStack, ZStack) —** Представления для организации других представлений в вертикальном, горизонтальном и наложенном порядке соответственно
```swift
VStack {
    Text("Top")
    Text("Bottom")
}
```
## Модификаторы
- Методы, которые применяются к представлениям для изменения их внешнего вида или поведения.
- **Каждый модификатор возвращает новое представление**, измененное в соответствии с примеренными параметрами.
- **Модификаторы цепочные,** что означает, что вы можете применять несколько модификаторов последовательно.

Пример:
```swift
Text("Hello, World!")
    .font(.title)
    .foregroundColor(.blue)
    .padding()
```
> *В этом примере текст сначала получает заголовочный шрифт `(.font(.title))`, затем синий цвет `(.foregroundColor(.blue))`, и, наконец, отступы `(.padding())`*
> 
## Модификаторы жизненного цикла View
SwiftUI включает три модификатора, которые реагируют на события жизненного цикла вью:

- `onAppear(perform:)` — выполняет действие при каждом появлении вью, даже если вью появилась не первый раз.
- `onDisappear(perform:)` — выполняет действие при уходе с вью.
- `task(priority:_:)` — выполняет действие в асинхронной среде при появлении вью. Перестает выполнять при уходе с вью (об этом подробнее в модуле **Concurrency**).

> *Ключевая разница между **onAppear** и **task** в том, что покидая вью **onAppear** не останавливает выполнение задачи, а **task** наоборот автоматически запускает и останавливает.*
>