
---

> **Изучение данного блока предполагает предварительное знание синтаксиса языка Swift.**
*Для успешного освоения этого материала, необходимо иметь базовое понимание синтаксиса языка Swift. Это включает в себя знание основных структур данных, операторов, циклов, функций, абстракций и других ключевых элементов языка. Без этих фундаментальных знаний будет сложно понять более сложные концепции и примеры, которые будут рассматриваться в данном блоке.*
> 

---
**Словари** в Swift — это коллекции, которые ассоциируют **уникальные ключи с определенными значениями**. Каждый ключ связан с одним значением, что позволяет быстро и эффективно искать значения по ключам. Словари в Swift являются **типами значений**, что означает, что когда вы копируете или присваиваете словарь, **создается новая копия этого словаря, а не ссылка на оригинал**.
### **Основные свойства словарей**
- **Уникальные ключи**

В словаре каждый ключ должен быть уникальным. Если вы попытаетесь добавить пару ключ-значение, где ключ уже существует, новое значение заменит старое.

- **Произвольный порядок**

Порядок элементов в словаре не гарантируется. Это значит, что при итерации по словарю порядок элементов может не совпадать с порядком их добавления.

- **Типы данных**

Типы ключей и значений в словаре должны быть определены. В Swift это делается с помощью обобщенных типов, например, Dictionary<Key, Value> или упрощенной записи [Key: Value].

**Пример создания словаря**
```swift
var dictionary: [String: Int] = ["one": 1, "two": 2, "three": 3]
```
Здесь мы создаем словарь, в котором ключи типа String связаны с значениями типа Int.
## **Основные методы работы со словарем**

### **Доступ по ключу**
**Получение значения**

Используйте синтаксис индексации для получения значения по ключу.
```swift
let value = dictionary["one"] // value будет равно 1
```
**Добавление или изменение значения**

Вы можете добавить новое значение или изменить существующее с помощью того же синтаксиса.
```swift
dictionary["four"] = 4
```
**Удаление значения**
```swift
dictionary.removeValue(forKey: "one")
```
**Получение значения с дефолтным значением**

Если вы хотите получить значение из словаря и при этом **избежать использования опционалов**, можно указать значение по умолчанию.
```swift
let value = dictionary["five", default: 0] // вернет 0, если ключ "five" отсутствует
```
### **Счетчик элементов**
Для того чтобы узнать количество пар ключ-значение в словаре, используется свойство count.
```swift
let count = dictionary.count
```
### **Проверка наличия ключа**
Метод **contains** позволяет проверить, содержится ли определенный ключ в словаре.
```swift
    let hasKey = dictionary.contains { $0.key == "two" }
    ```
Еще один способ — использовать **keys.contains/value.contains**:
```swift
    let exists = dictionary.keys.contains("two")
    ```
### **Итерация по словарю**
Используя цикл **for-in**, можно пройтись по всем ключам и значениям в словаре.
```swift
for (key, value) in dictionary {
    print("\(key): \(value)")
}
```
### **Извлечение ключей и значений**
Для получения всех ключей или значений в виде массива можно использовать свойства **keys** и **values**.
```swift
let keys = Array(dictionary.keys)
let values = Array(dictionary.values)
```
### **Слияние словарей**
Вы можете объединить два словаря, используя метод **merge(_:uniquingKeysWith:)**. Если ключи совпадают, вы можете выбрать, какое значение сохранить.
```swift
var dict1 = ["a": 1, "b": 2]
let dict2 = ["b": 3, "c": 4]
dict1.merge(dict2) { (current, _) in current } // сохранит старое значение
// dict1 теперь ["a": 1, "b": 2, "c": 4]
```
### **Преобразование и фильтрация**
Метод **mapValues(_:)** позволяет трансформировать значения в словаре.
```swift
let multipliedValues = dictionary.mapValues { $0 * 2 }
// multipliedValues = ["one": 2, "two": 4, "three": 6]
```
Словарь можно также фильтровать, используя метод **filter(_:).**
```swift
let filteredDictionary = dictionary.filter { $0.value > 1 }
// filteredDictionary = ["two": 2, "three": 3]
```
### **Обратное присваивание**
Можно безопасно изменять значения словаря, используя методы **updateValue(_:forKey:)**, который возвращает старое значение ключа, если оно существовало.
```swift
let oldValue = dictionary.updateValue(5, forKey: "two")
```
### **Инициализация через последовательности**
Можно создавать словари из массивов **пар ключ-значение**.
```swift
let pairs = [("one", 1), ("two", 2), ("three", 3)]
let dictionary = Dictionary(uniqueKeysWithValues: pairs)
```
### **Создание словарей из массивов**
**Swift** позволяет создавать словари из массивов с использованием метода **Dictionary(uniqueKeysWithValues:)** или **Dictionary(grouping:by:)**.
```swift
let names = ["Alice", "Bob", "Charlie"]
let nameDictionary = Dictionary(uniqueKeysWithValues: zip(names, 1...3))
// nameDictionary = ["Alice": 1, "Bob": 2, "Charlie": 3]

let groupedNames = Dictionary(grouping: names) { $0.first! }
// groupedNames = ["A": ["Alice"], "B": ["Bob"], "C": ["Charlie"]]
```
## **Хеш-таблицы и их роль в реализации словарей**
> *Этот раздел может показаться сложным для **Junior разработчиков**, но важно получить общее представление о том, как это работает. На следующем грейде мы углубимся в эту тему и рассмотрим её более детально.*
> 

**Хеш-таблица** — это основная структура данных, используемая для реализации словарей в Swift. Хеш-таблицы позволяют быстро находить элементы по ключу, обеспечивая операции доступа, добавления и удаления за среднее время O(1). Это достигается за счет использования хеш-функции, которая преобразует ключ в индекс, по которому значение хранится в массиве.
### **Принципы работы хеш-таблицы***
Когда элемент добавляется в словарь, хеш-функция вычисляет индекс на основе ключа. Этот индекс указывает на позицию в массиве, где будет храниться значение. Если несколько ключей дают одинаковый индекс (**коллизия**), Swift использует метод открытой адресации с линейным пробированием, чтобы найти следующую доступную ячейку в массиве.

Хеш-таблица в Swift организована как несколько массивов: массив ключей, массив значений и битовая карта, указывающая, какие позиции заняты. Эта структура позволяет эффективно управлять памятью и обеспечивает быстрый доступ к элементам.