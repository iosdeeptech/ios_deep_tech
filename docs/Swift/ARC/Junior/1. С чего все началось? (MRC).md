
---
> **Изучение данного блока предполагает предварительное знание синтаксиса языка Swift.**
*Для успешного освоения этого материала, необходимо иметь базовое понимание синтаксиса языка Swift/Obj C. Это включает в себя знание основных структур данных, операторов, циклов, функций, абстракций и других ключевых элементов языка. Без этих фундаментальных знаний будет сложно понять более сложные концепции и примеры, которые будут рассматриваться в данном блоке.*
> 
---

**MRC (Manual Retain-Release Counting)** — это механизм управления памятью, который использовался в языке программирования Objective-C до появления автоматического управления памятью (**ARC — Automatic Reference Counting**, *о нем мы поговорим в следующих статьях*). 

В MRC разработчики вручную контролировали время жизни объектов, вызывая методы управления ссылками. Это требовало тщательного понимания работы подсчёта ссылок, структуры объектов в памяти и правил их использования.

### Исторический контекст
До введения **ARC**, управление памятью в **Objective-C** было одной из сложнейших задач для разработчиков. Подсчёт ссылок требовал высокой дисциплины: ошибка могла привести либо к утечкам памяти (**memory leaks**), либо к преждевременному освобождению объектов и последующим сбоям (**dangling pointers**). **MRC** был тесно связан с фундаментальными принципами работы **runtime** системы **Objective-C**, что обеспечивало низкоуровневый контроль над памятью, но также вносило значительные риски и увеличивало сложность разработки.
### **Reference Counting**
**Подсчёт ссылок** — это механизм, при котором каждый объект отслеживает количество активных ссылок на него. Когда объект создаётся, его **счётчик ссылок (retain count)** устанавливается в 1. Каждый раз, когда кто-то “удерживает” объект, счётчик увеличивается на 1, а когда освобождает — уменьшается на 1. Когда счётчик достигает нуля, объект освобождается из памяти.
### Основные понятия MRC
**MRC** базировался на подсчёте ссылок для управления временем жизни объектов. В основе этого механизма были четыре ключевых метода: `alloc`, `retain`, `release`, и `autorelease`.

#### **`alloc/init` — инициализация объекта**
При создании нового объекта с помощью `alloc`, его счётчик ссылок (**retain count**) устанавливается в 1. Это означает, что объект будет жить в памяти до тех пор, пока его кто-то “удерживает”.

Метод `init` используется для инициализации состояния объекта после его создания.
```objective-c
MyClass *obj = [[MyClass alloc] init]; // retain count = 1
```
#### **`retain` — увеличение счётчика ссылок**
`retain` увеличивает счётчик ссылок объекта на единицу, указывая, что кто-то ещё нуждается в объекте. Это предотвращает его удаление до тех пор, пока счётчик ссылок не снизится до нуля.
```objective-c
[obj retain]; // retain count = 2
```
#### **`release` — уменьшение счётчика ссылок**
`release` уменьшает счётчик ссылок на единицу. Если счётчик достигает нуля, вызывается метод `dealloc`, и объект освобождается из памяти.
```objective-c
[obj release]; // retain count = 1
[obj release]; // retain count = 0, объект удалён
```
#### **`autorelease` — отложенное освобождение**
`autorelease` добавляет объект в **autorelease pool**, который действует в рамках текущего цикла выполнения (**run loop**). Объект будет автоматически освобождён при завершении текущего цикла.
```objective-c
[obj autorelease]; // Объект будет освобождён в будущем
```
## **Autorelease Pool**
Это механизм, позволяющий откладывать освобождение объектов до определённого момента в будущем. Когда объекту отправляется сообщение **autorelease**, он добавляется в текущий активный **Autorelease Pool**. При опустошении пула всем объектам в нём отправляется сообщение **release**.
#### Как это работает?
1. Создаётся новый **Autorelease Pool**, который начинает собирать объекты.
2. При вызове **[object autorelease]** объект добавляется в текущий пул (**retain count** объекта не изменяется сразу).
3. При вызове **[pool drain]** или выходе из блока **@autoreleasepool**, всем объектам в пуле отправляется **release**.
4. Если **retain count** достигает 0, объект освобождается.

Пулы могут быть вложенными, объекты освобождаются при опустошении соответствующего пула.
## **Проблемы и нюансы работы с MRC**
#### **Memory Leaks**
Объект остаётся в памяти, потому что **release** не был вызван достаточное количество раз.
```objective-c
(void)createObject {
    MyClass *obj = [[MyClass alloc] init];
    // Нет вызова [obj release]; утечка памяти
}
```
К последствиям можно отнести повышенное потребление памяти, и как следствие, краш приложения из-за нехватки ресурсов. 
#### **Dangling Pointers**
Обращение к объекту после его освобождения.
```objective-c
MyClass *obj = [[MyClass alloc] init];
[obj release];
obj = nil;
[obj doSomething]; // Без обнуления obj это приведёт к крашу
```
#### **Retain Cycles**
Два или более объекта удерживают друг друга, и ни один не освобождается.
```objective-c
// Parent.h
@interface Parent : NSObject
@property (nonatomic, retain) Child *child;
@end

// Child.h
@interface Child : NSObject
@property (nonatomic, retain) Parent *parent;
@end
```
Решение:
```objective-c
// Child.h
@interface Child : NSObject
@property (nonatomic, assign) Parent *parent; // Используем assign
@end
```
#### **Каскадное освобождение объектов**
При освобождении объекта необходимо освободить все объекты, которыми он владеет.
```objective-c
@interface MyClass : NSObject
@property (nonatomic, retain) NSString *name;
@property (nonatomic, retain) NSArray *items;
@end

@implementation MyClass

- (void)dealloc {
    [_name release];
    [_items release];
    [super dealloc];
}

@end
```
#### **Сложность при управлении большими проектами**
В больших кодовых базах управление памятью вручную может стать сложной задачей, так как необходимо тщательно отслеживать, кто и когда владеет объектом. Один пропущенный вызов `release` может привести к утечкам, тогда как слишком частое его использование — к крашам.
#### **Избыточность кода**
Каждый объект должен быть правильно удержан и освобождён. Это приводит к значительному увеличению кода, в котором нужно постоянно вызывать `retain` и `release`.
## **Переход от MRC к ARC**
С выходом **Xcode 4.2** был представлен **ARC (Automatic Reference Counting)**, который существенно упростил работу с памятью. В **ARC** вызовы `retain`, `release`, и `autorelease` генерируются автоматически компилятором, что устраняет необходимость ручного управления памятью. **ARC** также минимизирует вероятность утечек памяти и ошибок, связанных с **dangling pointers**.

Однако **ARC** по сути является обёрткой над **MRC** и использует тот же механизм подсчёта ссылок, освобождая разработчиков от необходимости вызывать методы `retain` и `release`, о чём мы более подробно поговорим в следующей части этого раздела.